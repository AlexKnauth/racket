#lang scribble/doc
@(require scribble/manual scribble/bnf "common.rkt" (for-label racket/base))

@title[#:tag "demod"]{@exec{raco demod}: Demodularizing Programs}

@declare-exporting[compiler/demodularizer/main]

The @exec{raco demodularize} command (usually used with the shorthand
@exec{raco demod}) takes a Racket module and flattens its
dependencies into a single compiled module. A file
@filepath{@nonterm{name}.rkt} is demodularized into
@filepath{@nonterm{name}_rkt_merged.zo}.

In its default configuration, @exec{raco demod} supports flattening a
module that represents an end-user program, so it discarding all
syntax, provides, and compile-time support in the module and its
dependencies. In that case,
the demodularized @filepath{.zo} file can be run by passing it as an
argument to the @exec{racket} command-line program, or it can be
turned into an executable with @seclink["exe"]{@exec{raco exe}}.

Supply the @Flag{s} or @DFlag{syntax} flag to preserve syntax,
provides, and compile-time components of the module, so that it can be
@racket[require]d the same as the original module. In that case,
modules whose instances need to be shared with other librraies should
be omitted from the demodularization using @Flag{x} or
@DFlag{exclude-library}. For example, @exec{-x racket/base} is
normally needed.

A large single module generated by the demodularizer may trigger size
limits in the compiler that prevent whole-module optimizations. Set
the @envvar{PLT_CS_COMPILE_LIMIT} environment variable to raise the
limit, and check @racket['info] logging at the @racket['linklet] topic
(e.g., set @envvar{PLTSTDERR} to @tt["info@linklet"]) for
information about when compilation is restricted to smaller functions.

The @exec{raco demod} command accepts these flags:

@itemlist[

 @item{@Flag{o} @nonterm{file} --- writes the flattened module to
       @nonterm{file} instead of
       @filepath{@nonterm{name}_@nonterm{ext}_merged.zo} for an input
       file @filepath{@nonterm{name}.@nonterm{ext}}.}

 @item{@Flag{x} @nonterm{module-path} or @DFlag{exclude-library} @nonterm{module-path} ---
       excludes the module in @nonterm{module-path} from flattening, as well
       as all of its dependencies.}

 @item{@Flag{e} @nonterm{path} or @DFlag{exclude-module} @nonterm{path} ---
       excludes the module in relative-file @nonterm{path} from flattening, as well
       as all of its dependencies.}

 @item{@Flag{s} or @DFlag{syntax} --- preserve syntax objects,
       provides, and phase levels greater than the run-time phase in
       the flattened result. Otherwise, only the run-time phase is
       preserved, and unused (or merely exported) definitions are
       pruned as possible.}

 @item{@DFlag{max-phase} @nonterm{phase} --- selects the maximum phase
       level to be preserved in the flattened module. For example, if
       a module exports macros, but those macros never expand to
       compile-time macros (other than ones provided by excluded
       modules), then a maximum phase level of 1 is sufficient.}

 @item{@Flag{M} or @DFlag{compile-any} --- flattens the module to
       machine-independent form, instead of recompiling the flattened
       module to the current platform and Racket virtual machine; the
       output generated with @Flag{M} loads more slowly than a
       machine-specific form, but @seclink["decompile"]{raco
       decompile} can show the flattened module in a format that is
       closer to source.}

 @item{@Flag{r} or @DFlag{recompile} --- (re)compiles the module to
        machine-dependent form after flattening; this mode is the
        default except on @BC, where flattening
        can work in terms of bytecode files.}

 @item{@DFlag{work} @nonterm{dir} --- uses @nonterm{dir} to cache
       compiled modules in an intermediate form for flattening; using
       @DFlag{work} with the same @nonterm{dir} for multiple uses of
       @exec{raco demod} can greatly speed up demodularization, and
       since the cache is based on @exec{raco make}, it works even
       with different input files or when modules to be flattened have
       changed since the last use of the cache.}

 @item{@Flag{g} or @DFlag{garbage-collect} --- aggressively prunes
       definitions that are unreferenced on the assumption that the
       right-hand side of a definition has no side effect; due to that
       unchecked assumption, this conversion may not preserve the
       behavior of the input module.}

 @item{@DFlag{dump} @nonterm{file} --- writes an S-expression
       representation of the module's content to @nonterm{file}, which
       can be helpful for understanding the content that is in the
       compiled flatten module.}

]

@history[#:changed "1.10" @elem{Added @Flag{M}/@DFlag{compile-any},
                                @DFlag{work}, and support for Racket CS.}
         #:changed "1.15" @elem{Added @Flag{x}/@DFlag{exclude-library},
                                @Flag{s}/@DFlag{syntax},
                                @DFlag{max-phase}, and @DFlag{dump}.}]
